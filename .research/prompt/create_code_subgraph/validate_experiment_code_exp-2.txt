
Input:
You are an AI code reviewer validating production-ready experiment code for research papers.

Your task is to compare the derived experiment_code with the original base_code to ensure that:
1. No important functionality has been omitted or truncated
2. All placeholders have been completely replaced with working implementations (no TODO, PLACEHOLDER, pass, or ... allowed)
3. The code is immediately executable and ready for research paper experiments
4. The derived code maintains the quality and completeness of the base foundation

# Instructions

## Core Validation Criteria
Check if the derived experiment code meets ALL of the following requirements:

1. **Complete Implementation Preservation**:
   - All functionality from base_code is preserved or properly enhanced
   - No code sections have been omitted or significantly shortened
   - Core algorithms and logic remain intact and functional
   - No reduction in code quality or completeness

2. **Complete Placeholder Replacement and Variation Implementation**:
   - All `DATASET_PLACEHOLDER` entries replaced with complete, working Hugging Face dataset loading
   - All `MODEL_PLACEHOLDER` entries replaced with complete, working model architectures
   - All `SPECIFIC_CONFIG_PLACEHOLDER` entries replaced with actual parameters
   - All run_variations are defined in both `config/smoke_test.yaml` and `config/full_experiment.yaml`
   - All run_variations are implemented in `src/model.py`
   - `config/smoke_test.yaml` contains ALL run variations in lightweight form
   - No TODO, PLACEHOLDER, pass, ..., or any incomplete implementations remain

3. **Functional Enhancement**:
   - Dataset-specific preprocessing is properly implemented
   - Model-specific configurations are correctly applied
   - Evaluation metrics are adapted for the specific experimental setup
   - All external resources are properly integrated

4. **Code Completeness**:
   - No truncated functions or incomplete implementations
   - All imports and dependencies are properly specified
   - Configuration files contain real experimental parameters
   - No "[UNCHANGED]" markers or similar placeholders remain

5. **Consistency with Base Code**:
   - Same file structure and organization
   - Consistent coding style and patterns
   - Proper error handling and logging maintained
   - All base functionality enhanced, not removed

## Detection of Common Issues
Flag the following problems if found:

- **Truncation**: Code sections that are significantly shorter than base_code equivalents
- **Omission**: Missing functions, classes, or important code blocks from base_code
- **Incomplete Replacement**: TODO, PLACEHOLDER, pass, ..., or any placeholder patterns that haven't been fully replaced with working code
- **Quality Degradation**: Simplified logic that reduces functionality
- **Structural Changes**: Unexpected modifications to the core architecture
- **Not Executable**: Code that cannot be run immediately due to missing implementations

## Output Format
Respond with a JSON object containing:
- `is_experiment_code_ready`: boolean - true if ALL criteria are met, false otherwise
- `experiment_code_issue`: string - specific issues found if any criteria are not met

# Current Research Method
{
    "Open Problems": "Even the fastest gray–box and multi-fidelity HPO methods (ASHA, PASHA, DyHPO, BOIL) still waste computation on obviously bad configurations because every trial is treated as a black box; none of the information that is already available inside the training loop – most notably the stochastic hyper-gradient obtained at almost zero cost with automatic differentiation – is used to steer the search. The open problem is: how can we inject very cheap, noisy hyper-gradient signals into existing bandit-style schedulers without redesigning their core logic?",
    "Methods": "We propose ‘One-Shot Hyper-Gradient Warm-Starts’ (OHGW), a drop-in modification for any Successive-Halving style scheduler (Hyperband / ASHA / PASHA).  1. When a new configuration x is sampled it is run for only one **mini-batch** (≈10-2% of a normal epoch).  2. In this first forward / backward pass we keep the compute graph and call automatic differentiation once more to obtain a single stochastic hyper-gradient ∂L/∂ψ for every continuous hyperparameter ψ (learning-rate, weight-decay, momentum …) exactly as in implicit hyper-gradient papers, but **without unrolling** (cost <1.2× normal mini-batch).  3. We apply one hyper-parameter update ψ←ψ−η_h ∂L/∂ψ (η_h is a fixed tiny step such as 10-3).  4. The adjusted configuration x′ – which differs from x by at most one gradient step in each hyper-parameter – is what the scheduler subsequently evaluates for its first rung (e.g. 1 epoch).  5. Everything else (promotion rules, budget doubling, stopping) is untouched.  In effect the scheduler still explores the same region, but every candidate is lightly nudged towards a valley before costly training starts.",
    "Experimental Setup": "Benchmark: CIFAR-10 with ResNet-20 and 5-dim continuous search space {log-lr, log-wd, momentum, augment-magnitude, label-smoothing}.  Scheduler baselines: ASHA, PASHA, DyHPO (their public implementations).  Our variants: ASHA+OHGW, PASHA+OHGW, DyHPO+OHGW (one-line wrapper around trial creation).  Mini-batch for warm-start: 128 images.  Hyper-gradient lr η_h=1e-3, computed with PyTorch autograd; no higher-order terms.  Each method is given the same overall GPU budget (4×V100 for 12 hours) and 50 seeds.  Metrics: (i) best test accuracy reached vs. wall-clock, (ii) total GPU hours until 93% accuracy, (iii) distribution of final hyper-parameters to check bias.",
    "Experimental Code": "# pseudo-code\nfor cfg in scheduler.sample():\n    model = build_model(cfg)\n    data = next(train_loader)            # one mini-batch\n    loss  = forward_loss(model, data)\n    grads = torch.autograd.grad(loss, cfg.continuous_params())\n    with torch.no_grad():               # one hyper step\n        for p,g in zip(cfg.continuous_params(), grads):\n            p -= eta_h * g\n    scheduler.launch(cfg)               # continue as usual",
    "Expected Result": "Across all schedules OHGW cuts the median time-to-93%-accuracy by ≈20% (ASHA 11.2→9.0 h, PASHA 7.3→5.8 h, DyHPO 6.1→4.9 h) while keeping the same final accuracy. The added warm-start costs <3% extra compute. Hyper-parameter distributions remain similar, showing no harmful bias.",
    "Expected Conclusion": "A single stochastic hyper-gradient step collected before the first rung is enough to noticeably reduce wasted resources in bandit-style HPO. Because OHGW requires only two extra autograd calls and no change to the scheduler logic, it can be retro-fitted to almost any existing gray-box optimizer, offering an attractive efficiency boost with negligible engineering effort."
}

# Experimental Design
## Experiment Strategy
Overall Experimental Strategy for Validating One-Shot Hyper-Gradient Warm-Starts (OHGW)

1. Core Hypotheses to Validate
   a. Efficiency: OHGW reduces wall-clock time and GPU hours needed by bandit-style schedulers to reach a preset performance threshold.
   b. Performance Preservation: OHGW does not hurt (and ideally preserves or slightly improves) the best final metric attainable by the underlying scheduler.
   c. Robustness & Variance: OHGW’s benefit is consistent across random seeds, search-space dimensionalities, data sets, model families and scheduler types.
   d. Generalization: The same one-line wrapper applies without retuning to tasks beyond image classification (e.g. language modelling, tabular, RL) and to both small- and large-scale training loops.
   e. Cost Overhead: Extra compute, memory and engineering overhead introduced by OHGW remain negligible (<5 % GPU-hours, <10 % peak-memory, ≤20 LoC integration).

2. Experiment Families (all experiments draw from one common pool of settings below)
   • Task Breadth: vision (CIFAR-10/100, ImageNet-1k), NLP (WikiText-103), tabular (UCI suite), RL (Atari).
   • Model Breadth: ResNet family, ViT, Transformer-LM, XGBoost, PPO-CNN.
   • Scheduler Breadth: ASHA, PASHA, DyHPO, Hyperband-BO, BOIL (if open-sourced).
   • Search-Space Breadth: 3–10 continuous hyper-parameters; mixed discrete+continuous cases to show neutrality to inapplicable params.
   • Scale Breadth: single-GPU up to 64-GPU distributed training (multi-node pools or simulated via concurrency on the 8×A100 machine).

3. Comparison Axes for Every Experiment
   • Baseline Scheduler (vanilla).
   • Baseline + Random Warm-Start in ∆ψ range (controls for mere perturbation).
   • Baseline + Multiple Hyper-Gradient Steps (ablation to check diminishing returns).
   • Scheduler-specific SoTA gradient-aware HPO if available (e.g. DyHPO, BOIL) to position OHGW competitively.

4. Metrics & Evaluation Protocol
   Primary quantitative metrics (reported as median ±IQR over ≥30 seeds):
      – T@τ: Wall-clock/GPU-hour to reach target score τ (task-specific; chosen so that vanilla reaches it within budget).
      – Best final validation/test score after fixed budget.
      – Compute Overhead: (Σ warm-start flop) ⁄ (total flop) and peak VRAM.
   Secondary diagnostics:
      – AUC of best-score-vs-time curve (overall sample efficiency).
      – Seed-wise variance of T@τ and final score.
      – Hyper-parameter trajectory statistics (mean shift & KL-divergence of posterior over ψ).
   Qualitative/visual:
      – Survival plots of promoted configurations per rung.
      – Heatmaps of hyper-gradient magnitude vs. eventual benefit.
   Statistical test: two-sided Wilcoxon signed-rank (α=0.05) on paired seeds.

5. Success Criteria (must hold in ≥75 % of experiment tuples)
   • ≥15 % median reduction in T@τ with p<0.05.
   • ≤0.2 % relative drop (or improvement) in best final score.
   • ≤5 % extra GPU-hours and ≤10 % extra peak VRAM.
   • Std-dev(T@τ) not inflated by more than 10 %.

6. Multi-Perspective Validation Plan
   • Efficiency: Use identical global budgets and identical seed lists; plot temporal efficiency curves and compute aggregated speed-up ratios.
   • Performance Preservation: Report final accuracy/F1/return and confidence intervals.
   • Robustness: Repeat each experiment block with different batch sizes, η_h values (10⁻⁴…10⁻²) and noisy labels; perform sensitivity analysis.
   • Generalization: Run a “zero-tuning transfer” study—apply the CIFAR-tuned η_h to NLP, RL and tabular tasks unchanged.
   • Ablations & Controls: Random perturbation, multistep hyper-gradient, frozen discrete params, partial gradient masking.
   • Scalability: Micro-benchmark warm-start time and memory for 1, 8, 64 GPUs using synthetic workloads.

7. Experimental Logistics
   • Central harness (Hydra + PyTorch Lightning) to register all trials, guarantee identical I/O pipelines and logging format (wandb/MLflow).
   • Dedicate 4×A100 per independent replicate to avoid resource contention; schedule via Slurm with cgroup accounting to record accurate GPU-hour usage.
   • Automated post-processing notebook generates unified tables, statistical tests and publication-ready plots.

8. Risk Mitigation & Contingency
   • If hyper-gradient extraction fails for exotic layers, fall back to finite-difference on ψ only (flag run but keep in aggregated stats).
   • If OHGW underperforms on discrete-heavy spaces, isolate continuous subset and document limitation.

This unified strategy guarantees that every forthcoming experiment—regardless of domain—collects commensurate evidence on efficiency, performance, robustness, generality and overhead, enabling a cohesive, multi-angle validation of OHGW’s claimed benefits.

# Base Code (Reference Foundation)
{"evaluate_py": "import argparse\nimport json\nimport os\nfrom pathlib import Path\nfrom typing import Dict, List\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.set(style=\"whitegrid\")\n\nFIGURE_NAMING_RULE = \"{topic}{condition}.pdf\"  # helper for consistent naming\n\n\ndef load_results(results_dir: Path) -\u003e List[Dict]:\n    runs = []\n    for run_dir in results_dir.iterdir():\n        if not run_dir.is_dir():\n            continue\n        res_file = run_dir / \"results.json\"\n        if res_file.exists():\n            with res_file.open() as f:\n                runs.append(json.load(f))\n    return runs\n\n\ndef bar_plot_accuracy(runs: List[Dict], out_path: Path):\n    labels = [r[\"run_id\"] for r in runs]\n    accs = [r[\"best_val_acc\"] for r in runs]\n\n    plt.figure(figsize=(6, 4))\n    ax = sns.barplot(x=labels, y=accs)\n    for idx, val in enumerate(accs):\n        ax.text(idx, val + 0.002, f\"{val:.3f}\", ha=\"center\", va=\"bottom\")\n    plt.ylabel(\"Best Validation Accuracy\")\n    plt.title(\"Comparison of Best Validation Accuracy Across Runs\")\n    plt.savefig(out_path, bbox_inches=\"tight\")\n    plt.close()\n\n\ndef line_plot_loss(runs: List[Dict], out_path: Path):\n    plt.figure(figsize=(6, 4))\n    for r in runs:\n        losses = [e[\"train_loss\"] for e in r[\"history\"]]\n        plt.plot(range(1, len(losses) + 1), losses, label=r[\"run_id\"])\n        # Annotate final value\n        plt.text(len(losses), losses[-1], f\"{losses[-1]:.3f}\")\n    plt.xlabel(\"Epoch\")\n    plt.ylabel(\"Training Loss\")\n    plt.title(\"Training Loss Curves\")\n    plt.legend()\n    plt.savefig(out_path, bbox_inches=\"tight\")\n    plt.close()\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Aggregate and visualise experiment results\")\n    parser.add_argument(\"--results-dir\", type=str, required=True, help=\"Directory containing run sub-folders\")\n    args = parser.parse_args()\n\n    results_dir = Path(args.results_dir)\n    runs = load_results(results_dir)\n    assert len(runs) \u003e 0, \"No results.json files found.\"\n\n    # ------------- Figures --------------\n    acc_out = results_dir / \"accuracy.pdf\"\n    loss_out = results_dir / \"training_loss.pdf\"\n    bar_plot_accuracy(runs, acc_out)\n    line_plot_loss(runs, loss_out)\n\n    # ----------- Numerical JSON ---------\n    summary = {\n        \"num_runs\": len(runs),\n        \"runs\": [{\"run_id\": r[\"run_id\"], \"best_val_acc\": r[\"best_val_acc\"], \"test_acc\": r[\"test_acc\"]} for r in runs]\n    }\n    print(json.dumps(summary, indent=2))\n\n\nif __name__ == \"__main__\":\n    main()\n", "full_experiment_yaml": "# Full experiment configuration template. Populate with actual variations in the specific-experiment step.\nexperiments:\n  # Example entry (to be replaced):\n  - run_id: baseline_schedulerA\n    model: MODEL_PLACEHOLDER  # PLACEHOLDER\n    dataset: DATASET_PLACEHOLDER  # PLACEHOLDER\n    scheduler: SCHEDULER_PLACEHOLDER  # PLACEHOLDER: ASHA / PASHA / etc.\n    epochs: 50\n    batch_size: 128\n    learning_rate: 0.1\n    weight_decay: 1e-4\n    momentum: 0.9\n    use_ohgw: false\n  - run_id: schedulerA_ohgw\n    model: MODEL_PLACEHOLDER\n    dataset: DATASET_PLACEHOLDER\n    scheduler: SCHEDULER_PLACEHOLDER\n    epochs: 50\n    batch_size: 128\n    learning_rate: 0.1\n    weight_decay: 1e-4\n    momentum: 0.9\n    use_ohgw: true\n    eta_h: 1e-3\n  # Add more variations as needed.\n\n# Global settings can be added here if required\n# e.g., default_num_workers: 8\n# These can be accessed in main.py if you extend logic accordingly.\n\n# End of full_experiment.yaml\n", "main_py": "import argparse\nimport json\nimport subprocess\nimport sys\nimport threading\nfrom pathlib import Path\nfrom typing import Dict, Any\n\nimport yaml\n\nCONFIG_DIR = Path(__file__).resolve().parent.parent / \"config\"\n\n\nclass Tee:\n    \"\"\"Tee that duplicates writes to multiple file-like objects (stdout + file).\"\"\"\n\n    def __init__(self, *files):\n        self.files = files\n\n    def write(self, data):\n        for f in self.files:\n            f.write(data)\n            f.flush()\n\n    def flush(self):\n        for f in self.files:\n            f.flush()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        for f in self.files:\n            try:\n                f.close()\n            except Exception:\n                pass\n\n\ndef stream_pipe(pipe, tee):\n    \"\"\"Continuously read from subprocess pipe and write to Tee.\"\"\"\n    for line in iter(pipe.readline, b\"\"):\n        decoded = line.decode()\n        tee.write(decoded)\n    pipe.close()\n\n\ndef run_experiment(run_cfg: Dict[str, Any], results_root: Path, smoke_test: bool):\n    run_id = run_cfg[\"run_id\"]\n    run_dir = results_root / run_id\n    run_dir.mkdir(parents=True, exist_ok=True)\n\n    # Write run-specific config to disk for train.py\n    cfg_path = run_dir / \"config.yaml\"\n    with cfg_path.open(\"w\") as f:\n        yaml.safe_dump(run_cfg, f)\n\n    cmd = [sys.executable, \"-m\", \"src.train\", \"--config\", str(cfg_path), \"--run-id\", run_id, \"--results-dir\",\n           str(run_dir)]\n    if smoke_test:\n        cmd.append(\"--smoke-test\")\n\n    process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=1)\n\n    # Prepare tee files\n    stdout_file = (run_dir / \"stdout.log\").open(\"w\")\n    stderr_file = (run_dir / \"stderr.log\").open(\"w\")\n\n    tee_out = Tee(sys.stdout, stdout_file)\n    tee_err = Tee(sys.stderr, stderr_file)\n\n    # Threaded streaming so both pipes are consumed concurrently\n    t_out = threading.Thread(target=stream_pipe, args=(process.stdout, tee_out))\n    t_err = threading.Thread(target=stream_pipe, args=(process.stderr, tee_err))\n    t_out.start()\n    t_err.start()\n\n    process.wait()\n    t_out.join()\n    t_err.join()\n\n    stdout_file.close()\n    stderr_file.close()\n\n    if process.returncode != 0:\n        raise RuntimeError(f\"Run {run_id} failed with return code {process.returncode}\")\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Experiment orchestrator: runs all variations and triggers evaluation\")\n    parser.add_argument(\"--smoke-test\", action=\"store_true\", help=\"Run lightweight smoke tests defined in smoke_test.yaml\")\n    parser.add_argument(\"--full-experiment\", action=\"store_true\", help=\"Run full experiment variations defined in full_experiment.yaml\")\n    parser.add_argument(\"--results-dir\", type=str, required=True, help=\"Root directory where all run sub-dirs and figures are saved\")\n    args = parser.parse_args()\n\n    if not (args.smoke_test ^ args.full_experiment):\n        parser.error(\"Exactly one of --smoke-test or --full-experiment must be specified.\")\n\n    cfg_file = CONFIG_DIR / (\"smoke_test.yaml\" if args.smoke_test else \"full_experiment.yaml\")\n    with cfg_file.open() as f:\n        cfg_data = yaml.safe_load(f)\n\n    experiments = cfg_data.get(\"experiments\", [])\n    if len(experiments) == 0:\n        raise ValueError(\"No experiments found in configuration file.\")\n\n    results_root = Path(args.results_dir)\n    results_root.mkdir(parents=True, exist_ok=True)\n\n    for run_cfg in experiments:\n        print(json.dumps({\"event\": \"start_run\", \"run_id\": run_cfg[\"run_id\"]}))\n        run_experiment(run_cfg, results_root, smoke_test=args.smoke_test)\n        print(json.dumps({\"event\": \"end_run\", \"run_id\": run_cfg[\"run_id\"]}))\n\n    # After all runs, trigger evaluation\n    eval_cmd = [sys.executable, \"-m\", \"src.evaluate\", \"--results-dir\", str(results_root)]\n    subprocess.run(eval_cmd, check=True)\n\n\nif __name__ == \"__main__\":\n    main()\n", "model_py": "\"\"\"Model architectures and hyper-parameter utilities.\"\"\"\n\nfrom typing import Dict\n\nimport torch\nimport torch.nn as nn\n\n__all__ = [\"get_model\", \"build_hyperparam_tensors\", \"apply_ohgw_step\"]\n\n\nclass SimpleCNN(nn.Module):\n    \"\"\"Baseline CNN that works for both grayscale and RGB images up to 32\u00d732.\"\"\"\n\n    def __init__(self, in_channels: int, num_classes: int):\n        super().__init__()\n        self.net = nn.Sequential(\n            nn.Conv2d(in_channels, 32, kernel_size=3, padding=1),\n            nn.BatchNorm2d(32),\n            nn.ReLU(),\n            nn.MaxPool2d(2),\n            nn.Conv2d(32, 64, kernel_size=3, padding=1),\n            nn.BatchNorm2d(64),\n            nn.ReLU(),\n            nn.MaxPool2d(2),\n            nn.Flatten(),\n            nn.Linear(64 * 7 * 7 if in_channels == 1 else 64 * 8 * 8, 128),\n            nn.ReLU(),\n            nn.Linear(128, num_classes),\n        )\n\n    def forward(self, x):\n        return self.net(x)\n\n\n# PLACEHOLDER: Additional architectures can be added here (ResNet, Transformer, etc.)\n\n\nMODEL_REGISTRY = {\n    \"MODEL_PLACEHOLDER\": SimpleCNN,  # Default fallback\n    \"baseline\": SimpleCNN,\n}\n\n\ndef get_model(name: str, input_shape, num_classes: int) -\u003e nn.Module:\n    \"\"\"Factory to build models given a name. Falls back to SimpleCNN if not found.\"\"\"\n    name = name.lower()\n    cls = MODEL_REGISTRY.get(name, SimpleCNN)\n    in_channels = input_shape[0]\n    return cls(in_channels, num_classes)\n\n\n# ---------------- Hyper-Param Tensors -----------------\n\ndef build_hyperparam_tensors(lr: float, weight_decay: float, momentum: float, device) -\u003e Dict[str, torch.Tensor]:\n    \"\"\"Represent continuous hyper-parameters as differentiable tensors for OHGW.\"\"\"\n    hypers = {\n        \"log_lr\": torch.tensor(float(torch.log(torch.tensor(lr))), dtype=torch.float32, requires_grad=True, device=device),\n        \"log_wd\": torch.tensor(float(torch.log(torch.tensor(weight_decay + 1e-12))), dtype=torch.float32, requires_grad=True, device=device),\n        \"momentum\": torch.tensor(momentum, dtype=torch.float32, requires_grad=True, device=device),\n    }\n    return hypers\n\n\n# ---------------- OHGW Core Logic --------------------\n\ndef apply_ohgw_step(model: nn.Module, hyperparams: Dict[str, torch.Tensor], train_loader, criterion, eta_h: float,\n                    device):\n    \"\"\"Perform One-Shot Hyper-Gradient Warm-Start as described in the research method.\"\"\"\n    model.train()\n    data_iter = iter(train_loader)\n    data, target = next(data_iter)\n    data, target = data.to(device), target.to(device)\n\n    # Forward pass with current hyper-params\n    output = model(data)\n    ce_loss = criterion(output, target)\n    reg_loss = torch.exp(hyperparams[\u0027log_wd\u0027]) * sum((p ** 2).sum() for p in model.parameters())\n    loss = ce_loss + reg_loss\n\n    # Compute gradients wrt hyper-parameters (stochastic hyper-grad)\n    hypers = list(hyperparams.values())\n    grads = torch.autograd.grad(loss, hypers, allow_unused=True)\n\n    # Gradient descent step in hyper-parameter space\n    with torch.no_grad():\n        for p, g in zip(hyperparams.values(), grads):\n            if g is not None:\n                p -= eta_h * g\n\n    # No need to modify model weights; they will be trained from scratch afterwards.\n    return hyperparams\n", "preprocess_py": "\"\"\"Common preprocessing utilities with dataset placeholders.\"\"\"\n\nfrom pathlib import Path\nfrom typing import Tuple\n\nimport torch\nfrom torch.utils.data import DataLoader, Dataset, random_split\nimport torchvision.transforms as T\nfrom torchvision.datasets import MNIST, CIFAR10\n\n# PLACEHOLDER: Will be replaced with specific dataset loading logic for each experiment\n\n\nclass DummyDataset(Dataset):\n    \"\"\"Synthetic dataset used when DATASET_PLACEHOLDER is specified or dataset not available.\"\"\"\n\n    def __init__(self, length: int = 512, num_classes: int = 10, input_shape=(1, 28, 28)):\n        self.length = length\n        self.num_classes = num_classes\n        self.input_shape = input_shape\n\n    def __len__(self):\n        return self.length\n\n    def __getitem__(self, idx):\n        x = torch.randn(self.input_shape)\n        y = torch.randint(0, self.num_classes, (1,)).item()\n        return x, y\n\n\ndef _split_dataset(dataset: Dataset, val_ratio: float = 0.1):\n    val_size = int(len(dataset) * val_ratio)\n    train_size = len(dataset) - val_size\n    return random_split(dataset, [train_size, val_size])\n\n\ndef load_dataset(name: str, batch_size: int = 128, num_workers: int = 4, smoke_test: bool = False):\n    \"\"\"Return train/val/test loaders and metadata.\"\"\"\n    transform = T.Compose([T.ToTensor()])\n\n    if name == \"DATASET_PLACEHOLDER\":\n        # Use synthetic dummy dataset\n        length = 128 if smoke_test else 2048\n        input_shape = (1, 28, 28)\n        num_classes = 10\n        full_ds = DummyDataset(length=length, num_classes=num_classes, input_shape=input_shape)\n        train_ds, val_ds = _split_dataset(full_ds, val_ratio=0.1)\n        test_ds = DummyDataset(length=int(length * 0.2), num_classes=num_classes, input_shape=input_shape)\n    elif name.lower() == \"mnist\":\n        root = Path.home() / \".cache/datasets\"\n        train_full = MNIST(root=root, train=True, download=True, transform=transform)\n        test_ds = MNIST(root=root, train=False, download=True, transform=transform)\n        train_ds, val_ds = _split_dataset(train_full, val_ratio=0.1)\n        input_shape = (1, 28, 28)\n        num_classes = 10\n    elif name.lower() == \"cifar10\":\n        root = Path.home() / \".cache/datasets\"\n        train_full = CIFAR10(root=root, train=True, download=True, transform=transform)\n        test_ds = CIFAR10(root=root, train=False, download=True, transform=transform)\n        train_ds, val_ds = _split_dataset(train_full, val_ratio=0.1)\n        input_shape = (3, 32, 32)\n        num_classes = 10\n    else:\n        raise ValueError(f\"Unknown dataset name: {name}. Implement loading logic in preprocess.py\")\n\n    train_loader = DataLoader(train_ds, batch_size=batch_size, shuffle=True, num_workers=num_workers)\n    val_loader = DataLoader(val_ds, batch_size=batch_size, shuffle=False, num_workers=num_workers)\n    test_loader = DataLoader(test_ds, batch_size=batch_size, shuffle=False, num_workers=num_workers)\n\n    return train_loader, val_loader, test_loader, input_shape, num_classes\n", "pyproject_toml": "[project]\nname = \"ohgw-experiments\"\nversion = \"0.1.0\"\ndescription = \"Common core foundation for OHGW experimental framework\"\nauthors = [\n  { name = \"Researcher\", email = \"researcher@example.com\" }\n]\nrequires-python = \"\u003e=3.9\"\nreadme = \"README.md\"\n\n[project.dependencies]\ntorch = \"*\"\ntorchvision = \"*\"\nPyYAML = \"*\"\nmatplotlib = \"*\"\nseaborn = \"*\"\nnumpy = \"*\"\ntqdm = \"*\"\n\n[build-system]\nrequires = [\"setuptools\u003e=61.0\"]\nbuild-backend = \"setuptools.build_meta\"\n", "smoke_test_yaml": "# Smoke test configuration with placeholder entries. Replace placeholders in derived experiments.\nexperiments:\n  - run_id: baseline_placeholder\n    model: MODEL_PLACEHOLDER  # PLACEHOLDER: specify concrete model name (e.g., resnet20) in derived experiments\n    dataset: DATASET_PLACEHOLDER  # PLACEHOLDER: specify dataset (e.g., cifar10)\n    epochs: 1\n    batch_size: 16\n    learning_rate: 1e-3\n    weight_decay: 1e-4\n    momentum: 0.9\n    use_ohgw: false\n  - run_id: proposed_placeholder\n    model: MODEL_PLACEHOLDER  # PLACEHOLDER: specify concrete model name\n    dataset: DATASET_PLACEHOLDER  # PLACEHOLDER: specify dataset name\n    epochs: 1\n    batch_size: 16\n    learning_rate: 1e-3\n    weight_decay: 1e-4\n    momentum: 0.9\n    use_ohgw: true\n    eta_h: 1e-3\n", "train_py": "import argparse\nimport json\nimport os\nimport random\nimport time\nfrom pathlib import Path\nfrom typing import Dict, Any\n\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom torch.utils.data import DataLoader\nfrom tqdm import tqdm\n\nfrom .preprocess import load_dataset\nfrom .model import get_model, build_hyperparam_tensors, apply_ohgw_step\n\n\ndef set_seed(seed: int = 42):\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    if torch.cuda.is_available():\n        torch.cuda.manual_seed_all(seed)\n\n\ndef accuracy(output: torch.Tensor, target: torch.Tensor) -\u003e float:\n    \"\"\"Compute top-1 accuracy.\"\"\"\n    with torch.no_grad():\n        preds = output.argmax(dim=1)\n        return (preds == target).float().mean().item()\n\n\ndef train_one_epoch(model: nn.Module, loader: DataLoader, criterion: nn.Module, optimizer: optim.Optimizer,\n                    device: torch.device, hyperparams: Dict[str, torch.Tensor]) -\u003e Dict[str, float]:\n    model.train()\n    running_loss = 0.0\n    running_acc = 0.0\n    for data, target in loader:\n        data, target = data.to(device), target.to(device)\n        optimizer.zero_grad()\n        output = model(data)\n        ce_loss = criterion(output, target)\n        reg_loss = 0.0\n        if \u0027log_wd\u0027 in hyperparams:\n            weight_decay = torch.exp(hyperparams[\u0027log_wd\u0027])\n            reg_loss = weight_decay * sum((p ** 2).sum() for p in model.parameters())\n        loss = ce_loss + reg_loss\n        loss.backward()\n        optimizer.step()\n        # Metrics\n        running_loss += loss.item() * data.size(0)\n        running_acc += accuracy(output, target) * data.size(0)\n    epoch_loss = running_loss / len(loader.dataset)\n    epoch_acc = running_acc / len(loader.dataset)\n    return {\"train_loss\": epoch_loss, \"train_acc\": epoch_acc}\n\n\ndef evaluate(model: nn.Module, loader: DataLoader, criterion: nn.Module, device: torch.device,\n             hyperparams: Dict[str, torch.Tensor]) -\u003e Dict[str, float]:\n    model.eval()\n    running_loss = 0.0\n    running_acc = 0.0\n    with torch.no_grad():\n        for data, target in loader:\n            data, target = data.to(device), target.to(device)\n            output = model(data)\n            ce_loss = criterion(output, target)\n            reg_loss = 0.0\n            if \u0027log_wd\u0027 in hyperparams:\n                weight_decay = torch.exp(hyperparams[\u0027log_wd\u0027])\n                reg_loss = weight_decay * sum((p ** 2).sum() for p in model.parameters())\n            loss = ce_loss + reg_loss\n            running_loss += loss.item() * data.size(0)\n            running_acc += accuracy(output, target) * data.size(0)\n    epoch_loss = running_loss / len(loader.dataset)\n    epoch_acc = running_acc / len(loader.dataset)\n    return {\"val_loss\": epoch_loss, \"val_acc\": epoch_acc}\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Run a single experiment variation (training + evaluation)\")\n    parser.add_argument(\"--config\", type=str, required=True, help=\"Path to the run-specific YAML config file\")\n    parser.add_argument(\"--run-id\", type=str, required=True, help=\"Unique identifier for this run (from YAML)\")\n    parser.add_argument(\"--results-dir\", type=str, required=True, help=\"Directory where outputs are stored\")\n    parser.add_argument(\"--smoke-test\", action=\"store_true\", help=\"Run a lightweight smoke test\")\n    args = parser.parse_args()\n\n    # Lazy import pyyaml to avoid unused dependency when train.py is imported elsewhere\n    import yaml\n\n    run_config: Dict[str, Any] = yaml.safe_load(Path(args.config).read_text())\n\n    results_dir = Path(args.results_dir)\n    results_dir.mkdir(parents=True, exist_ok=True)\n\n    set_seed(run_config.get(\"seed\", 42))\n\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n    # ---------------- Data ----------------\n    batch_size = run_config.get(\"batch_size\", 128 if not args.smoke_test else 16)\n    num_workers = run_config.get(\"num_workers\", 4)\n    train_loader, val_loader, test_loader, input_shape, num_classes = load_dataset(\n        run_config.get(\"dataset\", \"DATASET_PLACEHOLDER\"), batch_size=batch_size, num_workers=num_workers,\n        smoke_test=args.smoke_test)\n\n    # ---------------- Model --------------\n    model_name = run_config.get(\"model\", \"MODEL_PLACEHOLDER\")\n    model = get_model(model_name, input_shape, num_classes)\n    model.to(device)\n\n    # ---------------- Hyper-Params -------\n    lr = float(run_config.get(\"learning_rate\", 1e-3))\n    weight_decay = float(run_config.get(\"weight_decay\", 1e-4))\n    momentum = float(run_config.get(\"momentum\", 0.9))\n\n    hyperparams = build_hyperparam_tensors(lr=lr, weight_decay=weight_decay, momentum=momentum, device=device)\n\n    optimizer = optim.SGD(model.parameters(), lr=lr, weight_decay=weight_decay, momentum=momentum)\n    criterion = nn.CrossEntropyLoss()\n\n    # ---------------- OHGW Warm-Start ----\n    if run_config.get(\"use_ohgw\", False):\n        eta_h = float(run_config.get(\"eta_h\", 1e-3))\n        apply_ohgw_step(model, hyperparams, train_loader, criterion, eta_h, device)\n        # Update optimizer with new hyper-params\n        new_wd = float(torch.exp(hyperparams[\u0027log_wd\u0027]).item()) if \u0027log_wd\u0027 in hyperparams else weight_decay\n        for pg in optimizer.param_groups:\n            pg[\u0027weight_decay\u0027] = new_wd\n\n    # --------------- Training Loop -------\n    epochs = int(run_config.get(\"epochs\", 20 if not args.smoke_test else 1))\n    history = []\n    best_val_acc = 0.0\n    start_time = time.time()\n    for epoch in range(1, epochs + 1):\n        train_metrics = train_one_epoch(model, train_loader, criterion, optimizer, device, hyperparams)\n        val_metrics = evaluate(model, val_loader, criterion, device, hyperparams)\n        best_val_acc = max(best_val_acc, val_metrics[\"val_acc\"])\n        epoch_metrics = {\n            \"epoch\": epoch,\n            **train_metrics,\n            **val_metrics,\n        }\n        history.append(epoch_metrics)\n        print(json.dumps({\"run_id\": args.run_id, **epoch_metrics}))\n\n    total_time = time.time() - start_time\n\n    # Final Test Evaluation\n    test_metrics = evaluate(model, test_loader, criterion, device, hyperparams)\n\n    # -------- Save Artifacts ----------\n    final_results = {\n        \"run_id\": args.run_id,\n        \"config\": run_config,\n        \"final_val_acc\": history[-1][\"val_acc\"],\n        \"best_val_acc\": best_val_acc,\n        \"test_acc\": test_metrics[\"val_acc\"],\n        \"epochs\": epochs,\n        \"total_time_sec\": total_time,\n        \"history\": history,\n    }\n\n    results_path = results_dir / \"results.json\"\n    with results_path.open(\"w\") as f:\n        json.dump(final_results, f, indent=2)\n\n    # Also print final summary so GitHub Actions can capture\n    print(json.dumps({\"run_id\": args.run_id, \"status\": \"completed\", \"best_val_acc\": best_val_acc, \"test_acc\": test_metrics[\"val_acc\"], \"total_time_sec\": total_time}))\n\n\nif __name__ == \"__main__\":\n    main()\n"}

# Current Experiment (To be validated)
- Experiment ID: exp-2
- Description: Objective / Hypothesis: Test zero-shot generalisation and robustness of OHGW in a different modality (language modelling) and under distribution shift.

Domain & Task: NLP – word-level language modelling on WikiText-103, with an additional OOD evaluation on WikiText-103-v1 (headlines first 5% shuffled – simulates domain drift).

Model: GPT2-small (124 M params, HuggingFace implementation) trained from scratch with BPE vocab 50 k.

Scheduler: PASHA (2023) – gradient-aware variation of Hyperband; ours wraps PASHA in the same way.

Search space (6 dims): log10-learning-rate, log10-weight-decay, attention-dropout, residual-dropout, label-smoothing, warmup-steps (continuous proxy by scaling factor).

Run variations:
• pasha-baseline – vanilla PASHA.
• pasha-ohgw-vision-tuned-eta – OHGW with η_h=1e-3 exactly copied from CIFAR experiment (tests transfer without retuning).
• pasha-ohgw-low-eta – OHGW with η_h=3e-4 (sensitivity extremum).
• pasha-ohgw-noisy-data – OHGW with η_h=1e-3 while 15% of training tokens are randomly replaced (robustness to noise).

Dataset processing: SentencePiece BPE (shared).  Sequence length 1024 tokens; dynamic batching up to 2M tokens/GPU.  Train/val/test split 238M / 8M / 8M tokens.  For OOD, evaluate perplexity on shuffled-headline subset (unseen ordering).

Training loop & budget: 50 training epochs (~250 k updates), AdamW, cosine LR.  PASHA minimum resource per config = 2 epochs, rungs ×2.  Total compute budget per replicate 16 GPU×hours (8 GPUs ×2 h).  24 replicates.

Evaluation metrics:
Primary – T@ppl=30 on validation set (wall-clock & GPU-h).
Secondary – best validation perplexity, best OOD perplexity, FLOPs overhead, peak VRAM, std-dev across seeds.
Calibration metric – ECE (expected calibration error) on top-k probabilities (k=10).

Data splitting: Configs use 90/10 split of train for inner-val to avoid test leakage; final report on held-out test.

Hyper-parameter analysis: log sweep of η_h done offline on 5 seeds; fit cubic spline to measure optimal region width (reports in appendix).

Robustness procedures:
1. Data noise: see pasha-ohgw-noisy-data.
2. Distribution shift: compute perplexity on OOD set after every rung, record Δppl.
3. Adversarial tokens: evaluate final models with TextFooler adversarial examples on 5 k sentences, report degradation.

Compute profiling: same toolkit as exp-1; additionally use PyTorch-CUDA-Profiler for kernel-level warm-start cost.

Example trial wrapper:
```python
loss = lm_model(input_ids, labels=input_ids).loss
hg = torch.autograd.grad(loss, cfg.continuous())
with torch.no_grad():
    for p,g in zip(cfg.continuous(), hg):
        p -= eta_h * g    # no extra unroll
pasha_scheduler.launch(cfg)
```

Statistical testing: Paired Wilcoxon on T@30 with Bonferroni correction (m=3 comparisons).  Significance if p<0.016.

Success criteria: vision-tuned η_h version achieves ≥15% speed-up vs. baseline on T@30 with ≤0.5 ppl regression on final test; effect still ≥10% under noisy data.  Extra compute overhead ≤5% of total FLOPs.
- Run Variations: ['pasha-baseline', 'pasha-ohgw-vision-tuned-eta', 'pasha-ohgw-low-eta', 'pasha-ohgw-noisy-data']

# Derived Experiment Code (To be validated)

{"evaluate_py": "import argparse\nimport json\nfrom pathlib import Path\nfrom typing import Dict, List\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.set(style=\"whitegrid\")\n\n\n# -----------------------------------------------------------------------------\n# Helpers\n# -----------------------------------------------------------------------------\n\ndef load_results(results_dir: Path) -\u003e List[Dict]:\n    runs = []\n    for run_dir in results_dir.iterdir():\n        if not run_dir.is_dir():\n            continue\n        res_file = run_dir / \"results.json\"\n        if res_file.exists():\n            with res_file.open() as f:\n                runs.append(json.load(f))\n    return runs\n\n\ndef summarise_runs(runs: List[Dict]):\n    summary = []\n    for r in runs:\n        metric_key = (\n            \"best_val_metric\" if \"best_val_metric\" in r else \"best_val_acc\"\n        )\n        summary.append({\n            \"run_id\": r[\"run_id\"],\n            \"best_val\": r.get(metric_key, None),\n            \"task_type\": r.get(\"task_type\", \"unknown\"),\n        })\n    return summary\n\n\ndef bar_plot(runs: List[Dict], out_path: Path):\n    summary = summarise_runs(runs)\n    labels = [s[\"run_id\"] for s in summary]\n    values = [s[\"best_val\"] for s in summary]\n\n    plt.figure(figsize=(6, 4))\n    ax = sns.barplot(x=labels, y=values)\n    for idx, val in enumerate(values):\n        ax.text(idx, val, f\"{val:.2f}\", ha=\"center\", va=\"bottom\")\n    plt.ylabel(\"Best Validation Metric (acc or ppl)\")\n    plt.title(\"Best Validation Metric Across Runs\")\n    plt.xticks(rotation=45)\n    plt.tight_layout()\n    plt.savefig(out_path)\n    plt.close()\n\n\n# -----------------------------------------------------------------------------\n# MAIN\n# -----------------------------------------------------------------------------\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description=\"Aggregate and visualise experiment results\"\n    )\n    parser.add_argument(\n        \"--results-dir\", type=str, required=True, help=\"Directory containing run sub-folders\"\n    )\n    args = parser.parse_args()\n\n    results_dir = Path(args.results_dir)\n    runs = load_results(results_dir)\n    assert len(runs) \u003e 0, \"No results.json files found in results directory.\"\n\n    # Simple bar plot of best validation metric\n    bar_plot_path = results_dir / \"best_val_metric.pdf\"\n    bar_plot(runs, bar_plot_path)\n\n    # JSON summary to stdout\n    print(json.dumps(summarise_runs(runs), indent=2))\n\n\nif __name__ == \"__main__\":\n    main()\n", "full_experiment_yaml": "experiments:\n  - run_id: pasha-baseline\n    model: gpt2_small\n    task_type: lm\n    dataset: wikitext103\n    seq_len: 1024\n    batch_size: 2\n    epochs: 50\n    learning_rate: 5e-4\n    weight_decay: 0.01\n    use_ohgw: false\n    eta_h: 0.0\n    noise_prob: 0.0\n    scheduler: pasha\n\n  - run_id: pasha-ohgw-vision-tuned-eta\n    model: gpt2_small\n    task_type: lm\n    dataset: wikitext103\n    seq_len: 1024\n    batch_size: 2\n    epochs: 50\n    learning_rate: 5e-4\n    weight_decay: 0.01\n    use_ohgw: true\n    eta_h: 1e-3\n    noise_prob: 0.0\n    scheduler: pasha\n\n  - run_id: pasha-ohgw-low-eta\n    model: gpt2_small\n    task_type: lm\n    dataset: wikitext103\n    seq_len: 1024\n    batch_size: 2\n    epochs: 50\n    learning_rate: 5e-4\n    weight_decay: 0.01\n    use_ohgw: true\n    eta_h: 3e-4\n    noise_prob: 0.0\n    scheduler: pasha\n\n  - run_id: pasha-ohgw-noisy-data\n    model: gpt2_small\n    task_type: lm\n    dataset: wikitext103\n    seq_len: 1024\n    batch_size: 2\n    epochs: 50\n    learning_rate: 5e-4\n    weight_decay: 0.01\n    use_ohgw: true\n    eta_h: 1e-3\n    noise_prob: 0.15\n    scheduler: pasha\n\n# End of configuration\n", "main_py": "import argparse\nimport json\nimport subprocess\nimport sys\nimport threading\nfrom pathlib import Path\nfrom typing import Dict, Any\n\nimport yaml\n\nCONFIG_DIR = Path(__file__).resolve().parent.parent / \"config\"\n\n\nclass Tee:\n    \"\"\"Tee that duplicates writes to multiple file-like objects (stdout + file).\"\"\"\n\n    def __init__(self, *files):\n        self.files = files\n\n    def write(self, data):\n        for f in self.files:\n            f.write(data)\n            f.flush()\n\n    def flush(self):\n        for f in self.files:\n            f.flush()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        for f in self.files:\n            try:\n                f.close()\n            except Exception:\n                pass\n\n\ndef stream_pipe(pipe, tee):\n    \"\"\"Continuously read from subprocess pipe and write to Tee.\"\"\"\n    for line in iter(pipe.readline, b\"\"):\n        decoded = line.decode()\n        tee.write(decoded)\n    pipe.close()\n\n\ndef run_experiment(run_cfg: Dict[str, Any], results_root: Path, smoke_test: bool):\n    run_id = run_cfg[\"run_id\"]\n    run_dir = results_root / run_id\n    run_dir.mkdir(parents=True, exist_ok=True)\n\n    # Write run-specific config to disk for train.py\n    cfg_path = run_dir / \"config.yaml\"\n    with cfg_path.open(\"w\") as f:\n        yaml.safe_dump(run_cfg, f)\n\n    cmd = [sys.executable, \"-m\", \"src.train\", \"--config\", str(cfg_path), \"--run-id\", run_id, \"--results-dir\",\n           str(run_dir)]\n    if smoke_test:\n        cmd.append(\"--smoke-test\")\n\n    process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=1)\n\n    # Prepare tee files\n    stdout_file = (run_dir / \"stdout.log\").open(\"w\")\n    stderr_file = (run_dir / \"stderr.log\").open(\"w\")\n\n    tee_out = Tee(sys.stdout, stdout_file)\n    tee_err = Tee(sys.stderr, stderr_file)\n\n    # Threaded streaming so both pipes are consumed concurrently\n    t_out = threading.Thread(target=stream_pipe, args=(process.stdout, tee_out))\n    t_err = threading.Thread(target=stream_pipe, args=(process.stderr, tee_err))\n    t_out.start()\n    t_err.start()\n\n    process.wait()\n    t_out.join()\n    t_err.join()\n\n    stdout_file.close()\n    stderr_file.close()\n\n    if process.returncode != 0:\n        raise RuntimeError(f\"Run {run_id} failed with return code {process.returncode}\")\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Experiment orchestrator: runs all variations and triggers evaluation\")\n    parser.add_argument(\"--smoke-test\", action=\"store_true\", help=\"Run lightweight smoke tests defined in smoke_test.yaml\")\n    parser.add_argument(\"--full-experiment\", action=\"store_true\", help=\"Run full experiment variations defined in full_experiment.yaml\")\n    parser.add_argument(\"--results-dir\", type=str, required=True, help=\"Root directory where all run sub-dirs and figures are saved\")\n    args = parser.parse_args()\n\n    if not (args.smoke_test ^ args.full_experiment):\n        parser.error(\"Exactly one of --smoke-test or --full-experiment must be specified.\")\n\n    cfg_file = CONFIG_DIR / (\"smoke_test.yaml\" if args.smoke_test else \"full_experiment.yaml\")\n    with cfg_file.open() as f:\n        cfg_data = yaml.safe_load(f)\n\n    experiments = cfg_data.get(\"experiments\", [])\n    if len(experiments) == 0:\n        raise ValueError(\"No experiments found in configuration file.\")\n\n    results_root = Path(args.results_dir)\n    results_root.mkdir(parents=True, exist_ok=True)\n\n    for run_cfg in experiments:\n        print(json.dumps({\"event\": \"start_run\", \"run_id\": run_cfg[\"run_id\"]}))\n        run_experiment(run_cfg, results_root, smoke_test=args.smoke_test)\n        print(json.dumps({\"event\": \"end_run\", \"run_id\": run_cfg[\"run_id\"]}))\n\n    # After all runs, trigger evaluation\n    eval_cmd = [sys.executable, \"-m\", \"src.evaluate\", \"--results-dir\", str(results_root)]\n    subprocess.run(eval_cmd, check=True)\n\n\nif __name__ == \"__main__\":\n    main()\n", "model_py": "\"\"\"Model architectures and OHGW utilities.\"\"\"\n\nfrom typing import Dict\n\nimport torch\nimport torch.nn as nn\n\n__all__ = [\"get_model\", \"build_hyperparam_tensors\", \"apply_ohgw_step\"]\n\n# -----------------------------------------------------------------------------\n# Simple CNN for image experiments\n# -----------------------------------------------------------------------------\n\n\nclass SimpleCNN(nn.Module):\n    \"\"\"A tiny CNN compatible with MNIST/CIFAR-like inputs.\"\"\"\n\n    def __init__(self, in_channels: int, num_classes: int):\n        super().__init__()\n        self.net = nn.Sequential(\n            nn.Conv2d(in_channels, 32, kernel_size=3, padding=1),\n            nn.BatchNorm2d(32),\n            nn.ReLU(),\n            nn.MaxPool2d(2),\n            nn.Conv2d(32, 64, kernel_size=3, padding=1),\n            nn.BatchNorm2d(64),\n            nn.ReLU(),\n            nn.MaxPool2d(2),\n            nn.Flatten(),\n            nn.Linear(64 * 7 * 7 if in_channels == 1 else 64 * 8 * 8, 128),\n            nn.ReLU(),\n            nn.Linear(128, num_classes),\n        )\n\n    def forward(self, x):\n        return self.net(x)\n\n\n# -----------------------------------------------------------------------------\n# GPT-2 small from scratch using HuggingFace transformers\n# -----------------------------------------------------------------------------\n\n\ndef _build_gpt2_small(vocab_size: int, seq_len: int = 1024, attn_drop: float = 0.1, resid_drop: float = 0.1):\n    from transformers import GPT2Config, GPT2LMHeadModel\n\n    config = GPT2Config(\n        vocab_size=vocab_size,\n        n_positions=seq_len,\n        n_ctx=seq_len,\n        n_embd=768,\n        n_layer=12,\n        n_head=12,\n        resid_pdrop=resid_drop,\n        attn_pdrop=attn_drop,\n    )\n    return GPT2LMHeadModel(config)\n\n\n# -----------------------------------------------------------------------------\n# Registry\n# -----------------------------------------------------------------------------\n\nMODEL_REGISTRY = {\n    \"simple_cnn\": SimpleCNN,\n    \"gpt2_small\": _build_gpt2_small,\n}\n\n\n# -----------------------------------------------------------------------------\n# Factory\n# -----------------------------------------------------------------------------\n\ndef get_model(name: str, input_shape, num_classes: int):\n    name = name.lower()\n    if name not in MODEL_REGISTRY:\n        raise ValueError(f\"Unknown model \u0027{name}\u0027. Available: {list(MODEL_REGISTRY.keys())}\")\n\n    if name == \"simple_cnn\":\n        in_channels = input_shape[0]\n        return MODEL_REGISTRY[name](in_channels, num_classes)\n    elif name == \"gpt2_small\":\n        # For GPT-2 we ignore input_shape; num_classes == vocab size\n        return MODEL_REGISTRY[name](vocab_size=num_classes)\n    else:\n        raise NotImplementedError\n\n\n# -----------------------------------------------------------------------------\n# Hyper-parameter tensors represented as differentiable scalars\n# -----------------------------------------------------------------------------\n\ndef build_hyperparam_tensors(lr: float, weight_decay: float, device) -\u003e Dict[str, torch.Tensor]:\n    hypers = {\n        \"log_lr\": torch.tensor(math.log(lr), dtype=torch.float32, requires_grad=True, device=device),\n        \"log_wd\": torch.tensor(\n            math.log(weight_decay + 1e-12), dtype=torch.float32, requires_grad=True, device=device\n        ),\n    }\n    return hypers\n\n\n# -----------------------------------------------------------------------------\n# OHGW implementation (generic for any task)\n# -----------------------------------------------------------------------------\n\nimport math\nfrom itertools import islice\n\n\ndef apply_ohgw_step(\n    model: nn.Module,\n    hyperparams: Dict[str, torch.Tensor],\n    train_loader,\n    eta_h: float,\n    device,\n    task_type: str,\n    criterion=None,\n):\n    \"\"\"One-Shot Hyper-Gradient Warm-Start.\n\n    We consume *one* mini-batch from *train_loader*, compute loss, take gradients\n    w.r.t. hyper-parameters (lr, wd) and apply a single update step of size\n    *eta_h* in hyper-parameter space.\n    \"\"\"\n\n    # Use first batch only\n    batch = next(iter(train_loader))\n    model.train()\n\n    if task_type == \"classification\":\n        data, target = batch\n        data, target = data.to(device), target.to(device)\n        logits = model(data)\n        ce_loss = criterion(logits, target)\n    else:  # language modelling\n        input_ids = batch[\"input_ids\"].to(device)\n        attention_mask = batch.get(\"attention_mask\", None)\n        if attention_mask is not None:\n            attention_mask = attention_mask.to(device)\n        labels = batch[\"labels\"].to(device)\n        outputs = model(input_ids=input_ids, attention_mask=attention_mask, labels=labels)\n        ce_loss = outputs.loss\n\n    reg_loss = torch.exp(hyperparams[\"log_wd\"]) * sum((p ** 2).sum() for p in model.parameters())\n    loss = ce_loss + reg_loss\n\n    # Hyper-gradients (no higher-order) wrt hyper-parameter tensors\n    grads = torch.autograd.grad(loss, list(hyperparams.values()), allow_unused=True)\n\n    with torch.no_grad():\n        for p, g in zip(hyperparams.values(), grads):\n            if g is not None:\n                p -= eta_h * g\n\n    return hyperparams\n", "preprocess_py": "\"\"\"Common preprocessing utilities with dataset placeholders.\"\"\"\n\nfrom pathlib import Path\nfrom typing import Tuple\n\nimport torch\nfrom torch.utils.data import DataLoader, Dataset, random_split\nimport torchvision.transforms as T\nfrom torchvision.datasets import MNIST, CIFAR10\n\n# PLACEHOLDER: Will be replaced with specific dataset loading logic for each experiment\n\n\nclass DummyDataset(Dataset):\n    \"\"\"Synthetic dataset used when DATASET_PLACEHOLDER is specified or dataset not available.\"\"\"\n\n    def __init__(self, length: int = 512, num_classes: int = 10, input_shape=(1, 28, 28)):\n        self.length = length\n        self.num_classes = num_classes\n        self.input_shape = input_shape\n\n    def __len__(self):\n        return self.length\n\n    def __getitem__(self, idx):\n        x = torch.randn(self.input_shape)\n        y = torch.randint(0, self.num_classes, (1,)).item()\n        return x, y\n\n\ndef _split_dataset(dataset: Dataset, val_ratio: float = 0.1):\n    val_size = int(len(dataset) * val_ratio)\n    train_size = len(dataset) - val_size\n    return random_split(dataset, [train_size, val_size])\n\n\ndef load_dataset(name: str, batch_size: int = 128, num_workers: int = 4, smoke_test: bool = False):\n    \"\"\"Return train/val/test loaders and metadata.\"\"\"\n    transform = T.Compose([T.ToTensor()])\n\n    if name == \"DATASET_PLACEHOLDER\":\n        # Use synthetic dummy dataset\n        length = 128 if smoke_test else 2048\n        input_shape = (1, 28, 28)\n        num_classes = 10\n        full_ds = DummyDataset(length=length, num_classes=num_classes, input_shape=input_shape)\n        train_ds, val_ds = _split_dataset(full_ds, val_ratio=0.1)\n        test_ds = DummyDataset(length=int(length * 0.2), num_classes=num_classes, input_shape=input_shape)\n    elif name.lower() == \"mnist\":\n        root = Path.home() / \".cache/datasets\"\n        train_full = MNIST(root=root, train=True, download=True, transform=transform)\n        test_ds = MNIST(root=root, train=False, download=True, transform=transform)\n        train_ds, val_ds = _split_dataset(train_full, val_ratio=0.1)\n        input_shape = (1, 28, 28)\n        num_classes = 10\n    elif name.lower() == \"cifar10\":\n        root = Path.home() / \".cache/datasets\"\n        train_full = CIFAR10(root=root, train=True, download=True, transform=transform)\n        test_ds = CIFAR10(root=root, train=False, download=True, transform=transform)\n        train_ds, val_ds = _split_dataset(train_full, val_ratio=0.1)\n        input_shape = (3, 32, 32)\n        num_classes = 10\n    else:\n        raise ValueError(f\"Unknown dataset name: {name}. Implement loading logic in preprocess.py\")\n\n    train_loader = DataLoader(train_ds, batch_size=batch_size, shuffle=True, num_workers=num_workers)\n    val_loader = DataLoader(val_ds, batch_size=batch_size, shuffle=False, num_workers=num_workers)\n    test_loader = DataLoader(test_ds, batch_size=batch_size, shuffle=False, num_workers=num_workers)\n\n    return train_loader, val_loader, test_loader, input_shape, num_classes\n", "pyproject_toml": "[project]\nname = \"ohgw-experiments\"\nversion = \"0.1.0\"\ndescription = \"OHGW experimental framework \u2013 executable code for all ablations\"\nauthors = [\n  { name = \"Researcher\", email = \"researcher@example.com\" }\n]\nrequires-python = \"\u003e=3.9\"\nreadme = \"README.md\"\n\n[project.dependencies]\ntorch = \"*\"\ntorchvision = \"*\"\nPyYAML = \"*\"\nmatplotlib = \"*\"\nseaborn = \"*\"\nnumpy = \"*\"\ntqdm = \"*\"\ntransformers = \"*\"\ndatasets = \"*\"\nsentencepiece = \"*\"\n\n[build-system]\nrequires = [\"setuptools\u003e=61.0\"]\nbuild-backend = \"setuptools.build_meta\"\n", "smoke_test_yaml": "experiments:\n  - run_id: pasha-baseline-smoke\n    model: gpt2_small\n    task_type: lm\n    dataset: wikitext103\n    seq_len: 128\n    batch_size: 2\n    epochs: 1\n    learning_rate: 5e-4\n    weight_decay: 0.01\n    use_ohgw: false\n    eta_h: 0.0\n    noise_prob: 0.0\n    scheduler: pasha\n\n  - run_id: pasha-ohgw-vision-tuned-eta-smoke\n    model: gpt2_small\n    task_type: lm\n    dataset: wikitext103\n    seq_len: 128\n    batch_size: 2\n    epochs: 1\n    learning_rate: 5e-4\n    weight_decay: 0.01\n    use_ohgw: true\n    eta_h: 1e-3\n    noise_prob: 0.0\n    scheduler: pasha\n\n  - run_id: pasha-ohgw-low-eta-smoke\n    model: gpt2_small\n    task_type: lm\n    dataset: wikitext103\n    seq_len: 128\n    batch_size: 2\n    epochs: 1\n    learning_rate: 5e-4\n    weight_decay: 0.01\n    use_ohgw: true\n    eta_h: 3e-4\n    noise_prob: 0.0\n    scheduler: pasha\n\n  - run_id: pasha-ohgw-noisy-data-smoke\n    model: gpt2_small\n    task_type: lm\n    dataset: wikitext103\n    seq_len: 128\n    batch_size: 2\n    epochs: 1\n    learning_rate: 5e-4\n    weight_decay: 0.01\n    use_ohgw: true\n    eta_h: 1e-3\n    noise_prob: 0.15\n    scheduler: pasha\n", "train_py": "import argparse\nimport json\nimport math\nimport random\nimport time\nfrom pathlib import Path\nfrom typing import Any, Dict\n\nimport numpy as np\nimport torch\nfrom torch.utils.data import DataLoader\nfrom tqdm import tqdm\n\nfrom .preprocess import load_dataset\nfrom .model import (\n    apply_ohgw_step,\n    build_hyperparam_tensors,\n    get_model,\n)\n\n\n# -----------------------------------------------------------------------------\n# Utility\n# -----------------------------------------------------------------------------\n\ndef set_seed(seed: int = 42):\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    if torch.cuda.is_available():\n        torch.cuda.manual_seed_all(seed)\n\n\n# -----------------------------------------------------------------------------\n# Training / Evaluation helpers that work for *both* classification \u0026 LM tasks\n# -----------------------------------------------------------------------------\n\ndef _classification_step(model, batch, criterion, device, hyperparams):\n    data, target = batch\n    data, target = data.to(device), target.to(device)\n    logits = model(data)\n    ce_loss = criterion(logits, target)\n    reg_loss = 0.0\n    if \"log_wd\" in hyperparams:\n        weight_decay = torch.exp(hyperparams[\"log_wd\"])\n        reg_loss = weight_decay * sum((p ** 2).sum() for p in model.parameters())\n    loss = ce_loss + reg_loss\n    preds = logits.argmax(dim=1)\n    correct = (preds == target).float().sum().item()\n    return loss, correct, data.size(0)\n\n\ndef _lm_step(model, batch, device):\n    input_ids = batch[\"input_ids\"].to(device)\n    attention_mask = batch.get(\"attention_mask\", None)\n    if attention_mask is not None:\n        attention_mask = attention_mask.to(device)\n    labels = batch[\"labels\"].to(device)\n    outputs = model(input_ids=input_ids, attention_mask=attention_mask, labels=labels)\n    # The model already applies CrossEntropyLoss internally\n    loss = outputs.loss\n    token_count = labels.numel()\n    return loss, token_count\n\n\ndef train_one_epoch(\n    model,\n    loader: DataLoader,\n    optimizer,\n    device,\n    hyperparams: Dict[str, torch.Tensor],\n    task_type: str,\n    criterion=None,\n):\n    model.train()\n    running_loss = 0.0\n    running_correct = 0.0\n    running_samples = 0\n    running_tokens = 0\n\n    pbar = tqdm(loader, desc=\"train\", leave=False)\n    for batch in pbar:\n        optimizer.zero_grad()\n        if task_type == \"classification\":\n            loss, correct, batch_size = _classification_step(\n                model, batch, criterion, device, hyperparams\n            )\n            loss.backward()\n            optimizer.step()\n            running_loss += loss.item() * batch_size\n            running_correct += correct\n            running_samples += batch_size\n            pbar.set_postfix(loss=loss.item())\n        else:  # language modelling\n            loss, token_count = _lm_step(model, batch, device)\n            loss.backward()\n            optimizer.step()\n            running_loss += loss.item() * token_count\n            running_tokens += token_count\n            pbar.set_postfix(loss=loss.item())\n\n    if task_type == \"classification\":\n        epoch_loss = running_loss / running_samples\n        epoch_acc = running_correct / running_samples\n        return {\"train_loss\": epoch_loss, \"train_acc\": epoch_acc}\n    else:\n        epoch_loss = running_loss / running_tokens\n        epoch_ppl = math.exp(epoch_loss)\n        return {\"train_loss\": epoch_loss, \"train_ppl\": epoch_ppl}\n\n\n@torch.no_grad()\ndef evaluate(model, loader: DataLoader, device, hyperparams: Dict[str, torch.Tensor], task_type: str, criterion=None):\n    model.eval()\n    running_loss = 0.0\n    running_correct = 0.0\n    running_samples = 0\n    running_tokens = 0\n    for batch in loader:\n        if task_type == \"classification\":\n            loss, correct, batch_size = _classification_step(\n                model, batch, criterion, device, hyperparams\n            )\n            running_loss += loss.item() * batch_size\n            running_correct += correct\n            running_samples += batch_size\n        else:\n            loss, token_count = _lm_step(model, batch, device)\n            running_loss += loss.item() * token_count\n            running_tokens += token_count\n\n    if task_type == \"classification\":\n        epoch_loss = running_loss / running_samples\n        epoch_acc = running_correct / running_samples\n        return {\"val_loss\": epoch_loss, \"val_acc\": epoch_acc}\n    else:\n        epoch_loss = running_loss / running_tokens\n        epoch_ppl = math.exp(epoch_loss)\n        return {\"val_loss\": epoch_loss, \"val_ppl\": epoch_ppl}\n\n\n# -----------------------------------------------------------------------------\n# MAIN\n# -----------------------------------------------------------------------------\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description=\"Run a single experiment variation (training + evaluation)\"\n    )\n    parser.add_argument(\"--config\", type=str, required=True, help=\"Path to the run-specific YAML config file\")\n    parser.add_argument(\"--run-id\", type=str, required=True, help=\"Unique identifier for this run (from YAML)\")\n    parser.add_argument(\"--results-dir\", type=str, required=True, help=\"Directory where outputs are stored\")\n    parser.add_argument(\"--smoke-test\", action=\"store_true\", help=\"Run a lightweight smoke test\")\n    args = parser.parse_args()\n\n    import yaml  # lazy import so module is optional when train.py imported elsewhere\n\n    run_config: Dict[str, Any] = yaml.safe_load(Path(args.config).read_text())\n    results_dir = Path(args.results_dir)\n    results_dir.mkdir(parents=True, exist_ok=True)\n\n    set_seed(run_config.get(\"seed\", 42))\n\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n    # ------------------------------------------------------------------ DATA\n    batch_size = run_config.get(\"batch_size\", 128 if not args.smoke_test else 8)\n    num_workers = run_config.get(\"num_workers\", 4)\n    seq_len = run_config.get(\"seq_len\", 128)\n    noise_prob = run_config.get(\"noise_prob\", 0.0)\n\n    train_loader, val_loader, test_loader, input_shape, num_classes = load_dataset(\n        name=run_config.get(\"dataset\", \"dummy\"),\n        batch_size=batch_size,\n        num_workers=num_workers,\n        smoke_test=args.smoke_test,\n        seq_len=seq_len,\n        noise_prob=noise_prob,\n    )\n\n    # ------------------------------------------------------------------ MODEL\n    model_name = run_config.get(\"model\", \"simple_cnn\").lower()\n    model = get_model(model_name, input_shape, num_classes)\n    model.to(device)\n\n    # Determine task type automatically if not provided\n    task_type = run_config.get(\"task_type\", \"lm\" if model_name.startswith(\"gpt2\") else \"classification\")\n\n    # ------------------------------------------------------------------ OPTIMISER \u0026 HYPERS\n    lr = float(run_config.get(\"learning_rate\", 1e-3))\n    weight_decay = float(run_config.get(\"weight_decay\", 1e-4))\n\n    hyperparams = build_hyperparam_tensors(lr=lr, weight_decay=weight_decay, device=device)\n\n    if task_type == \"classification\":\n        import torch.optim as optim\n\n        momentum = float(run_config.get(\"momentum\", 0.9))\n        optimizer = optim.SGD(\n            model.parameters(), lr=lr, weight_decay=weight_decay, momentum=momentum\n        )\n        criterion = torch.nn.CrossEntropyLoss()\n    else:\n        from torch.optim import AdamW\n\n        optimizer = AdamW(model.parameters(), lr=lr, weight_decay=weight_decay)\n        criterion = None  # model returns internal loss\n\n    # ---------------------------------------------------------- OHGW Warm-Start\n    if run_config.get(\"use_ohgw\", False):\n        eta_h = float(run_config.get(\"eta_h\", 1e-3))\n        apply_ohgw_step(\n            model=model,\n            hyperparams=hyperparams,\n            train_loader=train_loader,\n            eta_h=eta_h,\n            device=device,\n            task_type=task_type,\n            criterion=criterion,\n        )\n        new_wd = float(torch.exp(hyperparams[\"log_wd\"]).item())\n        for pg in optimizer.param_groups:\n            pg[\"weight_decay\"] = new_wd\n\n    # -------------------------------------------------------------- TRAIN LOOP\n    epochs = int(run_config.get(\"epochs\", 10 if not args.smoke_test else 1))\n    history = []\n    best_val_metric = None  # accuracy for classification, ppl for lm\n\n    start_time = time.time()\n    for epoch in range(1, epochs + 1):\n        train_metrics = train_one_epoch(\n            model,\n            train_loader,\n            optimizer,\n            device,\n            hyperparams,\n            task_type=task_type,\n            criterion=criterion,\n        )\n        val_metrics = evaluate(\n            model,\n            val_loader,\n            device,\n            hyperparams,\n            task_type=task_type,\n            criterion=criterion,\n        )\n\n        # select metric direction\n        if task_type == \"classification\":\n            current_metric = val_metrics[\"val_acc\"]\n            if best_val_metric is None or current_metric \u003e best_val_metric:\n                best_val_metric = current_metric\n        else:\n            current_metric = val_metrics[\"val_ppl\"]\n            if best_val_metric is None or current_metric \u003c best_val_metric:\n                best_val_metric = current_metric\n\n        epoch_metrics = {\"epoch\": epoch, **train_metrics, **val_metrics}\n        history.append(epoch_metrics)\n        # Print for real-time monitoring\n        print(json.dumps({\"run_id\": args.run_id, **epoch_metrics}))\n\n    total_time = time.time() - start_time\n\n    # ---------------------------------------------------------- FINAL TEST\n    test_metrics = evaluate(\n        model,\n        test_loader,\n        device,\n        hyperparams,\n        task_type=task_type,\n        criterion=criterion,\n    )\n\n    # ------------------------------------------------------ SAVE RESULTS\n    final_results = {\n        \"run_id\": args.run_id,\n        \"config\": run_config,\n        \"task_type\": task_type,\n        \"best_val_metric\": best_val_metric,\n        \"test_metrics\": test_metrics,\n        \"epochs\": epochs,\n        \"total_time_sec\": total_time,\n        \"history\": history,\n    }\n\n    results_path = results_dir / \"results.json\"\n    with results_path.open(\"w\") as f:\n        json.dump(final_results, f, indent=2)\n\n    # Summary line for CI parsing\n    print(\n        json.dumps(\n            {\n                \"run_id\": args.run_id,\n                \"status\": \"completed\",\n                \"best_val_metric\": best_val_metric,\n                \"total_time_sec\": total_time,\n            }\n        )\n    )\n\n\nif __name__ == \"__main__\":\n    main()\n"}


Compare the Base Code with the Derived Experiment Code for this specific experiment thoroughly. Ensure the derived code maintains all the quality, completeness, and functionality of the base code while properly replacing placeholders with specific implementations.
Output:
{
    "is_experiment_code_ready": false,
    "experiment_code_issue": "1. Dataset loader not implemented: preprocess.load_dataset still only supports MNIST/CIFAR/placeholder; config requests 'wikitext103'. Call from train.py passes extra args (seq_len, noise_prob) causing TypeError and ValueError.\n2. PLACEHOLDER comments remain in preprocess; requirement of full replacement violated.\n3. evaluate.py lost line_plot_loss functionality from base (omission).\n4. smoke_test/full_experiment YAML include new run variations but smoke_test.yaml in derived replaced; however not all variations from full config exist in smoke test as required (should contain ALL variations in lightweight form, missing baseline? It has baseline but names differ vs full variations; still mapping but ok). More critical above.\n5. No PASHA scheduler integration; scheduler param unused; missing external scheduling logic.\n6. Overall code not executable, breaks criteria 3 & 4."
}
